[{"description":"Add the contents of **WREG** to file register `f`.\n- `d = 0` → result is stored in **WREG**.\n- `d = 1` → result is stored back into register `f`.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; d=0, a=0  → result in WREG, Access bank\nADDWF 0xFF, 0, 0   ; W = 0xFF + W","; d=0, a=1  → result in WREG, Banked address\nADDWF 0xFF, 0, 1   ; W = 0xFF + W","; d=1, a=0  → result back to file register, Access bank\nADDWF 0xFF, 1, 0   ; 0xFF = 0xFF + W","; d=1, a=1  → result back to file register, Banked address\nADDWF 0xFF, 1, 1   ; 0xFF = 0xFF + W","; Load literal into WREG then add, result in WREG (Access bank)\nADDWF 0xFF, 0, 0   ; W = 0xFF + 0xFF"],"category":"Byte-oriented File Register Operations","name":"ADDWF","short":"Add WREG to f"},{"description":"Add the contents of **WREG** and the carry bit to file register `f`.\n- `d = 0` → result is stored in **WREG**.\n- `d = 1` → result is stored back into register `f`.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.\n- The carry flag is updated based on the result.","examples":["; d=0, a=0  → result in WREG, Access bank\nADDWFC 0x20, 0, 0   ; W = W + 0x20 + C","; d=0, a=1  → result in WREG, Banked address\nADDWFC 0x20, 0, 1   ; W = W + 0x20 + C","; d=1, a=0  → result back to file register, Access bank\nADDWFC 0x20, 1, 0   ; 0x20 = 0x20 + W + C","; d=1, a=1  → result back to file register, Banked address\nADDWFC 0x20, 1, 1   ; 0x20 = 0x20 + W + C","; Load literal into WREG then add, result in WREG (Access bank)\nMOVLW 0x10\nADDWFC 0x20, 0, 0   ; W = W + 0x20 + C"],"category":"Byte-oriented File Register Operations","name":"ADDWFC","short":"Add WREG and Carry bit to f"},{"description":"AND the contents of **WREG** with file register `f`.\n- `d = 0` → result is stored in **WREG**.\n- `d = 1` → result is stored back into register `f`.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; d=0, a=0  → result in WREG, Access bank\nANDWF 0x21, 0, 0   ; W = 0x21 & W","; d=0, a=1  → result in WREG, Banked address\nANDWF 0x21, 0, 1   ; W = 0x21 & W","; d=1, a=0  → result back to file register, Access bank\nANDWF 0x21, 1, 0   ; 0x21 = 0x21 & W","; d=1, a=1  → result back to file register, Banked address\nANDWF 0x21, 1, 1   ; 0x21 = 0x21 & W","; Load literal into WREG then AND, result in WREG (Access bank)\nMOVLW 0x0F\nANDWF 0x21, 0, 0   ; W = 0x21 & 0x0F"],"category":"Byte-oriented File Register Operations","name":"ANDWF","short":"AND WREG with f"},{"description":"Clear the contents of a file register `f`. The register is set to `0` and no value is written back to **WREG**. The **a** operand selects the address space: `a = 0` for the access bank, `a = 1` for a banked area.","examples":["; a=0  → Clear register in Access bank\nCLRF 0x20, 0   ; 0x20 = 0x00","; a=1  → Clear register in Banked address\nCLRF 0x20, 1   ; 0x20 = 0x00 (banked)"],"category":"Byte-oriented File Register Operations","name":"CLRF","short":"Clear f"},{"description":"Complement the contents of file register **f**.\n- The instruction performs a bitwise logical negate (NOT) of register `f`.\n- The result is stored **WREG** if `d = 0` or back into register `f` if `d = 1`.\n- The `a = 0` option selects the **Access Bank**; `a = 1` selects the **Banked** addressing mode.\n- The `Z` flag is set if the result is zero; the `C` flag remains unchanged.","examples":["; d=0, a=0  → result in WREG, Access bank\nCOMF 0x20, 0, 0 ; W = ~0x20","; d=0, a=1  → result in WREG, Banked address\nCOMF 0x20, 0, 1 ; W = ~0x20","; d=1, a=0  → result back to file register, Access bank\nCOMF 0x20, 1, 0 ; 0x20 = ~0x20","; d=1, a=1  → result back to file register, Banked address\nCOMF 0x20, 1, 1 ; 0x20 = ~0x20","; Load literal into WREG then complement, result in WREG (Access bank)\nMOVLW 0x10\nCOMF 0x20, 0, 0 ; W = ~0x20"],"category":"Byte-oriented File Register Operations","name":"COMF","short":"Complement f"},{"description":"Compare file register `f` with the contents of **WREG**. If the two values are equal, the next instruction is skipped.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; a=0 – compare register in access bank, skip if equal\nCPFSEQ 0x20, 0 ; skips next if W = 0x20","; a=1 – compare register in banked address, skip if equal\nCPFSEQ 0x62, 1 ; skips next if W = value at 0x62 in banked area","; Load literal into WREG then compare access bank\nMOVLW 0x20\nCPFSEQ 0x20, 0 ; skips next if W = 0x20 (equal)","; Load literal into WREG then compare banked address\nMOVLW 0x20\nCPFSEQ 0x62, 1 ; skips next if W = 0x20 (equal)","; Load literal into WREG, compare with different register value – no skip\nMOVLW 0x10\nCPFSEQ 0x20, 0 ; W = 0x10, f = 0x20 – next instruction executed"],"category":"Byte-oriented File Register Operations","name":"CPFSEQ","short":"Compare f with WREG, skip ="},{"description":"Compare the contents of file register **f** with **WREG**. If **WREG** contains a value greater than that in **f**, the instruction immediately following the compare instruction is skipped. The instruction also updates the Status register: Z is set when the values are equal and C is set when **WREG** > f.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; a=0, WREG < f, no skip\nCPFSGT 0x10, 0 ; W = 0x05, f = 0x07 → Next instruction executes","; a=0, WREG > f, skip\nCPFSGT 0x10, 0 ; W = 0x09, f = 0x07 → Next instruction is skipped","; a=1, WREG < f, no skip\nCPFSGT 0x0100, 1 ; W = 0x15, f = 0x20 → Next instruction executes","; a=1, WREG > f, skip\nCPFSGT 0x0100, 1 ; W = 0x25, f = 0x20 → Next instruction is skipped","; Load literal into WREG then compare, skip if greater\nMOVLW 0x12\nCPFSGT 0x10, 0 ; W = 0x12, f = 0x07 → Next instruction is skipped"],"category":"Byte-oriented File Register Operations","name":"CPFSGT","short":"Compare f with WREG, skip if >"},{"description":"Compare the contents of a file register **f** with the current contents of **WREG**. If **f** is less than **WREG**, the next instruction in program memory will be skipped. No flags are set and **WREG** is unaffected.\n- Syntax: `CPFSLT f`.\n- The operand `f` is a single‑byte file register; it can be any address in the access bank or the banked memory but no additional addressing options are available.","examples":["; f (0x10) < WREG (0x30) → skip next instruction\nCPFSLT 0x10   ; 0x10 < 0x30, next instruction is skipped","; f (0x20) = WREG (0x20) → no skip\nCPFSLT 0x20   ; 0x20 = 0x20, next instruction executes","; f (0x30) > WREG (0x10) → no skip\nCPFSLT 0x30   ; 0x30 > 0x10, next instruction executes","; WREG preloaded with literal 0x07, f (0x04) < WREG → skip next instruction\nCPFSLT 0x04   ; 0x04 < 0x07, next instruction is skipped","; WREG contains 0x12, f (0x12) = WREG → no skip\nCPFSLT 0x12   ; 0x12 = 0x12, next instruction executes"],"category":"Byte-oriented File Register Operations","name":"CPFSLT","short":"Compare f with WREG, skip if <"},{"description":"Decrement the contents of file register `f` by 1.\n- `d = 0` → result is stored in **WREG**.\n- `d = 1` → result is stored back into register `f`.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; d=0, a=0  → result in WREG, Access bank\nDECF 0x20, 0, 0   ; W = 0x20-1","; d=0, a=1  → result in WREG, Banked address\nDECF 0x20, 0, 1   ; W = 0x20-1","; d=1, a=0  → result back to file register, Access bank\nDECF 0x20, 1, 0   ; 0x20 = 0x20-1","; d=1, a=1  → result back to file register, Banked address\nDECF 0x20, 1, 1   ; 0x20 = 0x20-1","; Pre-load WREG with literal, decrement f, result in WREG (Access bank)\nMOVLW 0x10\nDECF 0x20, 0, 0   ; W = 0x20-1"],"category":"Byte-oriented File Register Operations","name":"DECF","short":"Decrement f"},{"description":"Decrement the contents of file register `f` by one.\n- The resulting value is either written back to `f` or to **WREG** depending on the **d** option.\n- If the decrement result is zero, the processor skips the following instruction.\n- `d = 0` → store result in **WREG**.\n- `d = 1` → store result back into file register `f`.\n- `a = 0` → use Access‑bank addressing for `f`.\n- `a = 1` → use Banked addressing for `f`.\n```asm\nDECFSZ f, [d], [a]\n```\n","examples":["; d=0, a=0  → result in WREG, Access bank\nDECFSZ 0x20, 0, 0   ; W = 0x20-1, skip if result is 0","; d=0, a=1  → result in WREG, Banked addressing\nDECFSZ 0x20, 0, 1   ; W = 0x20-1, skip if result is 0","; d=1, a=0  → result back to file register, Access bank\nDECFSZ 0x20, 1, 0   ; 0x20 = 0x20-1, skip if result is 0","; d=1, a=1  → result back to file register, Banked addressing\nDECFSZ 0x20, 1, 1   ; 0x20 = 0x20-1, skip if result is 0","; Load literal into WREG then decrement (result stored in WREG, Access bank)\nMOVLW 0x10\nDECFSZ 0x20, 0, 0   ; W = 0x20-1, skip if result is 0"],"category":"Byte-oriented File Register Operations","name":"DECFSZ","short":"Decrement f, Skip if 0"},{"description":"Decrement the contents of the file register `f` by one. The result is written back into `f`. The Zero (Z) flag is updated to show whether the new value is zero. If the result **is not zero**, the next instruction is skipped (PC is incremented by two). If the result **is zero**, execution proceeds normally.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; a=0 (Access bank) – decrement, skip if result is not zero\nDCFSNZ 0x20, 0   ; 0x20 = 0x20‑1; if result≠0, PC+=2","; a=0 (Access bank) – decrement until zero (no skip)\nDCFSNZ 0x20, 0   ; if result=0, PC++","; a=1 (Banked) – decrement, skip if result is not zero\nDCFSNZ 0x120, 1   ; banked addressing; skip if result≠0","; a=1 (Banked) – decrement until zero (no skip)\nDCFSNZ 0x120, 1   ; if result=0, PC++"],"category":"Byte-oriented File Register Operations","name":"DCFSNZ","short":"Decrement f, Skip if Not 0"},{"description":"Increment the contents of file register `f`.\n- `d = 0` → result is stored in **WREG**.\n- `d = 1` → result is stored back into register `f`.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; d=0, a=0  → result in WREG, Access bank\nINCF 0x20, 0, 0   ; W = 0x20 + 1","; d=0, a=1  → result in WREG, Banked address\nINCF 0x20, 0, 1   ; W = 0x20 + 1","; d=1, a=0  → result stored back into f, Access bank\nINCF 0x20, 1, 0   ; 0x20 = 0x20 + 1","; d=1, a=1  → result stored back into f, Banked address\nINCF 0x20, 1, 1   ; 0x20 = 0x20 + 1","; Load literal into WREG then increment, result in WREG (Access bank)\nMOVLW 0x10\nINCF 0x20, 0, 0   ; W = 0x20 + 1"],"category":"Byte-oriented File Register Operations","name":"INCF","short":"Increment f"},{"description":"Increment the contents of file register `f` by one and *skip* the next instruction if the result is zero.\n- `d = 0` → The incremented value is written to **WREG**; otherwise it is written back to `f`.\n- `d = 1` → The incremented value is written back to `f`.\n- `a = 0` → The operand `f` refers to the Access bank.\n- `a = 1` → The operand `f` refers to the Banked register file.","examples":["; d=0, a=0  → result in WREG, Access bank\nINCFSZ 0x07, 0, 0   ; 0x07 = 0x07 + 1 → result in WREG, skip if zero","; d=0, a=1  → result in WREG, Banked address\nINCFSZ 0x100, 0, 1   ; 0x100 = 0x100 + 1 → result in WREG, skip if zero","; d=1, a=0  → result stored back in f, Access bank\nINCFSZ 0x07, 1, 0   ; 0x07 = 0x07 + 1 → result in f, skip if zero","; d=1, a=1  → result stored back in f, Banked address\nINCFSZ 0x100, 1, 1   ; 0x100 = 0x100 + 1 → result in f, skip if zero","; Load literal into WREG, then increment f with result written to WREG\nMOVLW 0x10\nINCFSZ 0x07, 0, 0   ; WREG = 0x07 + 1 after increment"],"category":"Byte-oriented File Register Operations","name":"INCFSZ","short":"Increment f, Skip if 0"},{"description":"Increment the contents of **f**. After incrementing, if the new value of **f** is **not zero** the following instruction is skipped. The instruction does not modify the carry flag, but updates the zero, negative and digit‑carry flags according to the new value of **f**.\n- `d = 0` → result is written to **WREG**.\n- `d = 1` → result is written back into register **f**.\n- `a = 0` → use access‑bank addressing.\n- `a = 1` → use banked addressing.","examples":["; d=0, a=0  → result in WREG, Access bank\nINFSNZ 0x20, 0, 0   ; 0x20 = 0x20+1, skip next if result != 0","; d=0, a=1  → result in WREG, Banked address\nINFSNZ 0x20, 0, 1   ; 0x20 = 0x20+1, skip next if result != 0","; d=1, a=0  → result back to file register, Access bank\nINFSNZ 0x20, 1, 0   ; 0x20 = 0x20+1, skip next if result != 0","; d=1, a=1  → result back to file register, Banked address\nINFSNZ 0x20, 1, 1   ; 0x20 = 0x20+1, skip next if result != 0","; Load literal into WREG then increment, result in WREG (Access bank)\nMOVLW 0x10\nINFSNZ 0x20, 0, 0   ; W = 0x20+1, skip next if result != 0"],"category":"Byte-oriented File Register Operations","name":"INFSNZ","short":"Increment f, Skip if Not 0"},{"description":"Perform an inclusive OR (logical OR) between the contents of **WREG** and a file register `f`.\n- `d = 0` → result is stored in **WREG**.\n- `d = 1` → result is stored back into register `f`.\n- `a = 0` → **Access‑bank** addressing.\n- `a = 1` → **Banked** addressing.","examples":["; d=0, a=0  → result in WREG, Access bank\nIORWF 0x24, 0, 0   ; WREG = 0x20 OR 0x0F = 0x2F","; d=0, a=1  → result in WREG, Banked address\nIORWF 0x24, 0, 1   ; WREG = 0x20 OR 0x0F = 0x2F","; d=1, a=0  → result stored in file register, Access bank\nIORWF 0x24, 1, 0   ; 0x24 = 0x20 OR 0x0F = 0x2F","; d=1, a=1  → result stored in file register, Banked address\nIORWF 0x24, 1, 1   ; 0x24 = 0x20 OR 0x0F = 0x2F","; Load literal into WREG then OR, result in WREG (Access bank)\nMOVLW 0x0F\nIORWF 0x24, 0, 0   ; WREG = 0x20 OR 0x0F = 0x2F"],"category":"Byte-oriented File Register Operations","name":"IORWF","short":"Inclusive OR WREG with f"},{"description":"Move the contents of **file register** `f` to another location.\n- `d = 0` → result is stored in **WREG** (copy to W).\n- `d = 1` → result overwrites the original file register `f` (copy to itself).\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; d=0, a=0  → copy to WREG, Access bank\nMOVF 0x30, 0, 0   ; W = 0x30","; d=0, a=1  → copy to WREG, Banked address\nMOVF 0x30, 0, 1   ; W = 0x30 (banked)","; d=1, a=0  → overwrite file register, Access bank\nMOVF 0x30, 1, 0   ; 0x30 = 0x30  (no change, but still writes)","; d=1, a=1  → overwrite file register, Banked address\nMOVF 0x30, 1, 1   ; 0x30 = 0x30 (banked)","; Pre-load WREG with literal, then copy to WREG (access bank)\nMOVLW 0x10\nMOVF 0x30, 0, 0   ; W = 0x30, overrides 0x10"],"category":"Byte-oriented File Register Operations","name":"MOVF","short":"Move f"},{"description":"Move the contents of the source file register `fs` to the destination file register `fd`. The instruction performs an 8‑bit copy from `fs` to `fd`; no additional modifiers such as `d` or `a` exist. The address supplied for each operand determines the bank automatically, so the programmer may specify an absolute file address that includes the bank bits.","examples":["; Move from access bank to access bank\nMOVFF 0x20, 0x21 ; 0x21 = 0x20","; Move from bank‑2 address to access bank\nMOVFF 0x92, 0x15 ; 0x15 = 0x92","; Move from access bank to bank‑1 address\nMOVFF 0x1F, 0x91 ; 0x91 = 0x1F","; Move between two banked addresses (bank 2 → bank 3)\nMOVFF 0x92, 0x13B ; 0x13B = 0x92"],"category":"Byte-oriented File Register Operations","name":"MOVFF","short":"Move fs (source) to fd (destination)"},{"description":"Move the contents of **WREG** to the file register `f`.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; a=0 → result stored in f (Access bank)\nMOVWF 0x1F, 0 ; 0x1F = W","; a=1 → result stored in f (Banked address)\nMOVWF 0x1F, 1 ; 0x1F = W","; Load literal into WREG then move, result in f (Access bank)\nMOVLW 0x0A\nMOVWF 0x1F, 0 ; 0x1F = 0x0A"],"category":"Byte-oriented File Register Operations","name":"MOVWF","short":"Move WREG to f"},{"description":"Multiply the contents of **WREG** with a file register `f`. The multiplication yields a 16‑bit product, with the low byte stored in **WREG** and the high byte stored in register `f`.\n- `d = 0` → The low byte of the product is stored in **WREG**; the high byte remains in `f` (the result is effectively in WREG and `f`).\n- `d = 1` → The product is written back into register `f` (the low byte goes to WREG and the high byte goes to `f`).\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; d=0, a=0  → product stored in WREG, Access bank\nMULWF 0x12, 0, 0   ; WREG = low*0x12, high byte stays in 0x12","; d=0, a=1  → product stored in WREG, Banked address\nMULWF 0xB0, 0, 1   ; WREG = low*0xB0, high byte stays in 0xB0","; d=1, a=0  → product written back to f, Access bank\nMULWF 0x12, 1, 0   ; 0x12 = high*0x12 and low part in WREG","; d=1, a=1  → product written back to f, Banked address\nMULWF 0xB0, 1, 1   ; 0xB0 = high*0xB0 and low part in WREG","; Load literal into WREG then multiply, result in WREG (Access bank)\nMOVLW 0x10\nMULWF 0x12, 0, 0   ; WREG = low*0x12, high byte stays in 0x12"],"category":"Byte-oriented File Register Operations","name":"MULWF","short":"Multiply WREG with f"},{"description":"Negate the contents of a byte‑wide file register `f`. The two's complement is written back to the same register. The result is always stored in the file register – there is no separate destination option.\n- `a = 0` → access‑bank addressing.\n- `a = 1` → banked addressing.","examples":["; a=0  → negate a register in the access bank\nNEGF 0x20, 0   ; 0x20 = 0 - 0x20","; a=1  → negate a register in the banked address space\nNEGF 0x20, 1   ; 0x20 = 0 - 0x20","; Load literal into WREG, copy to a register and negate (Access bank)\nMOVLW 0x10\nMOVWF 0x20, 0\nNEGF 0x20, 0   ; 0x20 = 0 - 0x10","; Load literal into WREG, copy to a register and negate (Banked addressing)\nMOVLW 0x10\nMOVWF 0x20, 1\nNEGF 0x20, 1   ; 0x20 = 0 - 0x10","; WREG pre‑loaded with a literal value, moved to a register and negated\nMOVLW 0x55\nMOVWF 0x20, 0\nNEGF 0x20, 0   ; 0x20 = 0 - 0x55"],"category":"Byte-oriented File Register Operations","name":"NEGF","short":"Negate f"},{"description":"Rotate a file register **f** left through the Carry bit.\n- `d = 0` → result is written to **WREG**.\n- `d = 1` → result is written back to register **f**.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; d=0, a=0  → result in WREG, Access bank","RLCF 0x1F, 0, 0   ; W = (0x1F << 1) + C (C becomes original bit 7 of 0x1F)","; d=0, a=1  → result in WREG, Banked address","RLCF 0x1F, 0, 1   ; W = (0x1F << 1) + C (banked 0x1F)","; d=1, a=0  → result back to file register, Access bank","RLCF 0x1F, 1, 0   ; 0x1F = (0x1F << 1) + C","; d=1, a=1  → result back to file register, Banked address","RLCF 0x1F, 1, 1   ; 0x1F = (0x1F << 1) + C (banked)","; Load literal into WREG then rotate file register, result in WREG (Access bank)","MOVLW 0x3C\nRLCF 0x1F, 0, 0   ; W = (0x1F << 1) + C with W pre‑loaded with 0x3C"],"category":"Byte-oriented File Register Operations","name":"RLCF","short":"Rotate Left f through Carry"},{"description":"Rotate the content of a **file register** `f` left by one bit while leaving the Carry flag unchanged.\n- `d = 0` → result is stored in **WREG**.\n- `d = 1` → result is stored back into register `f`.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing. The bit shifted out of bit 7 is discarded and a `0` is shifted into bit 0.","examples":["; d=0, a=0  → result in WREG, Access bank\nRLNCF 0x20, 0, 0   ; W = (0x20 << 1) & 0xFF","; d=0, a=1  → result in WREG, Banked address\nRLNCF 0x20, 0, 1   ; W = (0x20 << 1) & 0xFF","; d=1, a=0  → result back to file register, Access bank\nRLNCF 0x20, 1, 0   ; 0x20 = (0x20 << 1) & 0xFF","; d=1, a=1  → result back to file register, Banked address\nRLNCF 0x20, 1, 1   ; 0x20 = (0x20 << 1) & 0xFF","; Load literal into WREG then rotate left, result in WREG (Access bank)\nMOVLW 0x10\nRLNCF 0x20, 0, 0   ; W = (0x20 << 1) & 0xFF"],"category":"Byte-oriented File Register Operations","name":"RLNCF","short":"Rotate Left f (No Carry)"},{"description":"Rotate the contents of a byte‑oriented file register `f` one bit to the right through the Carry flag.\n- `a = 0` → use the Access Bank for `f`.\n- `a = 1` → use the Banked memory for `f`.\n\nThe least‑significant bit of `f` is moved into the Carry flag; the original Carry entry is shifted into bit 7 of the register. The new value is written back to `f`.","examples":["; a=0  → rotate in Access bank\nRRCF 0x20, 0 ; 0x20 = (0x20 >> 1) | (C << 7)","; a=1  → rotate in Banked address\nRRCF 0x20, 1 ; 0x20 = (0x20 >> 1) | (C << 7)","; Load 0x3 into 0x20 then rotate, a=0\nMOVLW 0x3\nMOVWF 0x20, 0\nRRCF 0x20, 0 ; 0x20 = (0x03 >> 1) | (C << 7)","; Load 0x80 into 0x20 then rotate, a=1\nMOVLW 0x80\nMOVWF 0x20, 1\nRRCF 0x20, 1 ; 0x20 = (0x80 >> 1) | (C << 7)","; Load 0xFF into 0x30 then rotate, a=0\nMOVLW 0xFF\nMOVWF 0x30, 0\nRRCF 0x30, 0 ; 0x30 = (0xFF >> 1) | (C << 7)"],"category":"Byte-oriented File Register Operations","name":"RRCF","short":"Rotate Right f through Carry"},{"description":"Rotate the contents of file register **f** one bit position to the right without affecting the **C** (carry) flag.\n- The least‑significant bit is discarded.\n- Bit 7 is loaded with logic **0** (logical shift right).\n- The **C** flag is preserved (no change).\n- The result is written either back to **f** or to **WREG** depending on *d*.\n- **d = 0** → result is stored in **WREG**.\n- **d = 1** → result is stored back into register **f**.\n- **a = 0** → Access bank addressing.\n- **a = 1** → Banked addressing.","examples":["; d=0, a=0  → rotate right, result in WREG, Access bank\nRRNCF 0x20, 0, 0   ; W = 0x20 >> 1 (carry unchanged)","; d=0, a=1  → rotate right, result in WREG, Banked address\nRRNCF 0x20, 0, 1   ; W = 0x20 >> 1 (carry unchanged)","; d=1, a=0  → rotate right, result back to f, Access bank\nRRNCF 0x20, 1, 0   ; 0x20 = 0x20 >> 1 (carry unchanged)","; d=1, a=1  → rotate right, result back to f, Banked address\nRRNCF 0x20, 1, 1   ; 0x20 = 0x20 >> 1 (carry unchanged)","; WREG preloaded with literal (unused), result in WREG\nMOVLW 0xAB\nRRNCF 0x20, 0, 0   ; W = 0x20 >> 1 (carry unchanged)"],"category":"Byte-oriented File Register Operations","name":"RRNCF","short":"Rotate Right f (No Carry)"},{"description":"The **SETF** instruction sets the specified file register to logical 1.\n- `d = 0` → the result (logic 1) is stored in **WREG**.\n- `d = 1` → the result is written back to the file register `f`.\n- The instruction does not use the `a` (access/banked) operand; addressing is performed using the normal file register syntax.","examples":["; d=0  → result in WREG\nSETF 0x20, 0   ; W = 1","; d=1  → result back to file register\nSETF 0x20, 1   ; 0x20 = 1"],"category":"Byte-oriented File Register Operations","name":"SETF","short":"Set f"},{"description":"Subtract the contents of file register `f` and the borrow flag from **WREG**.\n- `d = 0` → result stored in **WREG**.\n- `d = 1` → result stored back into register `f`.\n- `a = 0` → Access bank addressing.\n- `a = 1` → Banked addressing.\n- The borrow flag is the status bit **C**; if **C = 0**, a borrow of 1 is subtracted, otherwise 0.\n- Status flags updated: **Z** (zero), **DC** (borrow from bit 3), **V** (overflow), and **C** (set if no borrow, cleared if borrow).","examples":["; d=0, a=0  → result in WREG, Access bank\nSUBFWB 0x20, 0, 0   ; W = W - 0x20 - borrow","; d=0, a=1  → result in WREG, Banked address\nSUBFWB 0x20, 0, 1   ; W = W - 0x20 - borrow (banked)","; d=1, a=0  → result back to file register, Access bank\nSUBFWB 0x20, 1, 0   ; 0x20 = W - 0x20 - borrow","; d=1, a=1  → result back to file register, Banked address\nSUBFWB 0x20, 1, 1   ; 0x20 = W - 0x20 - borrow (banked)","; Load literal into WREG then subtract with borrow, result in WREG (Access bank)\nMOVLW 0x07\nSUBFWB 0x05, 0, 0   ; W = 0x07 - 0x05 - borrow"],"category":"Byte-oriented File Register Operations","name":"SUBFWB","short":"Subtract f from WREG with borrow"},{"description":"Subtract the contents of **WREG** from file register `f`.\n- `d = 0` → result is stored in **WREG**.\n- `d = 1` → result is stored back into register `f`.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; d=0, a=0  → result in WREG, Access bank\nSUBWF 0x20, 0, 0   ; W = 0x20 - W","; d=0, a=1  → result in WREG, Banked address\nSUBWF 0x20, 0, 1   ; W = 0x20 - W","; d=1, a=0  → result back to file register, Access bank\nSUBWF 0x20, 1, 0   ; 0x20 = 0x20 - W","; d=1, a=1  → result back to file register, Banked address\nSUBWF 0x20, 1, 1   ; 0x20 = 0x20 - W","; Load literal into WREG then subtract, result in WREG (Access bank)\nMOVLW 0x05\nSUBWF 0x20, 0, 0   ; W = 0x20 - 0x05"],"category":"Byte-oriented File Register Operations","name":"SUBWF","short":"Subtract WREG from f"},{"description":"Subtract **WREG** from file register `f` with borrow.\n- `d = 0` → result stored in **WREG**.\n- `d = 1` → result stored back into register `f`.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.\n- The borrow is taken from the Carry flag; if **C** is cleared an extra 1 is subtracted.","examples":["; d=0, a=0  → result in WREG, Access bank\nSUBWFB 0x30, 0, 0   ; W = 0x30 - W - borrow","; d=0, a=1  → result in WREG, Banked address\nSUBWFB 0x30, 0, 1   ; W = 0x30 - W - borrow","; d=1, a=0  → result back to f, Access bank\nSUBWFB 0x30, 1, 0   ; 0x30 = 0x30 - W - borrow","; d=1, a=1  → result back to f, Banked address\nSUBWFB 0x30, 1, 1   ; 0x30 = 0x30 - W - borrow","; Load literal into WREG then subtract, result in WREG (Access bank)\nMOVLW 0x10\nSUBWFB 0x30, 0, 0   ; W = 0x30 - 0x10 - borrow"],"category":"Byte-oriented File Register Operations","name":"SUBWFB","short":"Subtract WREG from f with borrow"},{"description":"Swap the upper and lower 4‑bit nibbles of the 8‑bit file register `f`.\n- The operation is performed in place on `f`.\n- `d = 0` → the swapped value is stored in **WREG**.\n- `d = 1` → the swapped value overwrites the original contents of register `f`.\n- There is *no* `a` (access‑bank) bit for SWAPF; the file register address can refer to any location.","examples":["; d=0 → result goes into WREG (Access bank example)\nSWAPF 0x20, 0   ; W = 0xBA  (if 0x20 originally contains 0xAB)","; d=1 → result written back to file register\nSWAPF 0x20, 1   ; 0x20 = 0xBA (if 0x20 originally contains 0xAB)","; Preload WREG with a literal, then d=0 → WREG is overwritten by swapped value\nMOVLW 0x10\nSWAPF 0x20, 0   ; W = 0xBA  (ignores previous WREG value)"],"category":"Byte-oriented File Register Operations","name":"SWAPF","short":"Swap nibbles in f"},{"description":"Test the contents of a file register `f`; if the register contains **zero**, the CPU skips the following instruction.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.\nThe instruction does not modify any registers. It only affects the program counter.","examples":["; a=0, register zero – next instruction skipped\nTSTFSZ 0x20, 0 ; if 0x20 == 0 skip the following instruction","; a=0, register non‑zero – instruction proceeds\nTSTFSZ 0x20, 0 ; if 0x20 != 0 execute the following instruction","; a=1, register zero – next instruction skipped\nTSTFSZ 0x20, 1 ; if 0x20 == 0 (banked address) skip the following instruction","; a=1, register non‑zero – instruction proceeds\nTSTFSZ 0x20, 1 ; if 0x20 != 0 (banked address) execute the following instruction"],"category":"Byte-oriented File Register Operations","name":"TSTFSZ","short":"Test f, skip if 0"},{"description":"Exclusive OR the contents of **WREG** with file register `f`.\n- `d = 0` → result is stored in **WREG**.\n- `d = 1` → result is stored back into register `f`.\n- `a = 0` → Access‑bank addressing.\n- `a = 1` → Banked addressing.","examples":["; d=0, a=0  → result in WREG, Access bank\nXORWF 0x20, 0, 0   ; W = W XOR 0x20 (Access bank)","; d=0, a=1  → result in WREG, Banked address\nXORWF 0x20, 0, 1   ; W = W XOR 0x20 (Banked)","; d=1, a=0  → result back to file register, Access bank\nXORWF 0x20, 1, 0   ; 0x20 = 0x20 XOR W (Access bank)","; d=1, a=1  → result back to file register, Banked address\nXORWF 0x20, 1, 1   ; 0x20 = 0x20 XOR W (Banked)","; Load literal into WREG then XOR, result in WREG (Access bank)\nMOVLW 0x55\nXORWF 0x20, 0, 0   ; W = W XOR 0x20 = 0x55 XOR 0x20"],"category":"Byte-oriented File Register Operations","name":"XORWF","short":"Exclusive OR WREG with f"},{"description":"Clear the bit specified by `b` in the file register `f`. The bit is set to 0 and all other bits in the register remain unchanged. The file register may be located in the access bank or in a banked area; the instruction automatically selects the correct bank based on the register address.","examples":["; Clear RP0 bit (bit 5) of the STATUS register (access bank)\nBCF STATUS,RP0 ; clear RP0 bit in STATUS register","; Clear bit 3 of the PORTA register (access bank)\nBCF PORTA,3 ; clear bit 3 in PORTA","; Clear bit 5 of a banked register located at address 0x70\nBCF 0x70,5 ; clear bit 5 in register 0x70","; Clear bit 2 of a user‑defined variable `myVar` (in GPR)\nBCF myVar,2 ; clear bit 2 in myVar","; Clear bit 0 of the PORTB register (PORTB is an SFR in the access bank)\nBCF PORTB,0 ; clear bit 0 in PORTB"],"category":"Bit-oriented File Register Operations","name":"BCF","short":"Bit Clear f"},{"description":"Set bit **b** of file register **f** to 1.\n- `a = 0` → Access‑bank addressing. The register address is interpreted in the access bank.\n- `a = 1` → Banked addressing. The register address is interpreted in the current bank selected by **BSR**.\n- `b` is the bit number (0‑7) to be set.\n\nThe bit set operation does not modify any of the status bits other than the **C** bit, which is **cleared**.","examples":["; a=0, bit 2, Access bank\nBSF 0x20, 2, 0   ; set bit 2 of register 0x20 to 1 (access bank)","; a=1, bit 2, Banked address\nBSF 0x20, 2, 1   ; set bit 2 of register 0x20 to 1 (banked address)","; a=0, bit 7, Access bank\nBSF 0x30, 7, 0   ; set bit 7 of register 0x30 to 1 (access bank)","; a=1, bit 7, Banked address\nBSF 0x30, 7, 1   ; set bit 7 of register 0x30 to 1 (banked address)","; Example with a preloaded literal (WREG is not used for BSF, but shown for completeness)\nMOVLW 0xFF\nBSF 0x20, 0, 0   ; set bit 0 of register 0x20 to 1 (access bank)"],"category":"Bit-oriented File Register Operations","name":"BSF","short":"Bit Set f"},{"description":"Test the bit value of a file register `f` at bit position `b`.\n- If the bit is **clear** (0), the CPU **skips** the next sequential instruction.\n- If the bit is **set** (1), the next instruction executes normally.\n- `a = 0` → Addressing uses the **access bank**.\n- `a = 1` → Addressing uses the **banked file registers**.","examples":["; Skip next instruction if RB2 is clear (Access bank)\nBTFSC PORTB, 2     ; Skip IF bit 2 of PORTB is clear\nCLRF  PORTC         ; Executed only if bit 2 of PORTB is set","; Test a banked register: skip if bit 5 of file register 0x78 is clear\nBTFSC 0x78, 5, 1   ; Skip IF bit 5 of file register 0x78 is clear\nCLRF  0x79          ; Executed only if bit 5 of 0x78 is set"],"category":"Bit-oriented File Register Operations","name":"BTFSC","short":"Bit Test f, Skip if Clear"},{"description":"Test the value of bit *b* in register *f*. If the bit is set (1), the processor automatically **skips the next instruction**. If the bit is clear (0), execution continues normally.\n- `a = 0` → *f* is addressed in the *Access bank*.\n- `a = 1` → *f* is addressed in a **banked** location.\n\n```asm\nBTFSS f, b [a]\n```\n","examples":["; a=0 (Access bank) – test bit 1 of PORTA, skip next if set\nBTFSS PORTA, 1   ; if PORTA bit1 is 1, the following instruction is skipped","; a=1 (Banked address) – test bit 4 of file register 0xF30, skip next if set\nBTFSS 0xF30, 4   ; if bit4 of 0xF30 is 1, the following instruction is skipped"],"category":"Bit-oriented File Register Operations","name":"BTFSS","short":"Bit Test f, Skip if Set"},{"description":"Toggle the state of a single bit in a file register.\nThe specified bit is flipped: 0 becomes 1 and 1 becomes 0.\n- **f** – the file register containing the target bit.\n- **b** – the bit position (0‑7) to toggle.\nThe instruction uses the current bank setting (access‑bank or banked) to resolve **f**.","examples":["; Toggle bit 3 of register 0x20 (Access bank)\nBTG 0x20, 3 ; bit 3 of 0x20 toggled","; Toggle bit 0 of register 0xF5 (Banked address)\nBTG 0xF5, 0 ; bit 0 of 0xF5 toggled","; Toggle bit 7 of register 0xA0 (Access bank)\nBTG 0xA0, 7 ; bit 7 of 0xA0 toggled","; Toggle bit 4 of register 0x00 (Access bank, example after previous toggles)\nBTG 0x00, 4 ; bit 4 of 0x00 toggled"],"category":"Bit-oriented File Register Operations","name":"BTG","short":"Bit Toggle f"},{"description":"BC – Branch if Carry. This instruction evaluates the Carry flag (C). If it is set, the Program Counter (PC) advances by two bytes, effectively skipping the following instruction. If the Carry flag is clear, PC advances by one byte so execution continues with the next instruction. This is a conditional skip, not an address‑relative branch.\n- `C = 1` → PC += 2  (skip next instruction)\n- `C = 0` → PC += 1  (continue normally)\nNo operands are required.","examples":["; Carry set, BC skips next instruction\nMOVLW 0xFF\nMOVWF 0x20\nADDWF 0x20, 1, 0\nBC\nNOP ; would be skipped","; Carry clear, BC does not skip\nMOVLW 0x00\nMOVWF 0x20\nADDWF 0x20, 1, 0\nBC\nNOP ; executed","; Skip NOP after addition that overflows, then fall through\nMOVLW 0xFF\nMOVWF 0x20\nADDWF 0x20, 1, 0\nBC\nNOP ; skipped\nGOTO 0x0100 ; executed"],"category":"Control Operations","name":"BC","short":"Branch if Carry"},{"description":"Branch to a target label if the **Negative (N)** status flag is set. If **N** = 1, the program counter is updated to the relative address of the target, otherwise execution continues with the next instruction. BN does not alter any registers or flags.\n- `N` flag is the test condition.","examples":["; Negative flag set, branch executed\nBN negTarget ; jumps to negTarget if N==1","; Negative flag not set, branch skipped\nBN negTarget ; no jump because N==0","; Use in a loop to continue while result is negative\nLOOP: MOVLW 0x80\nSUBWF counter, 0 ; sets N\nBN LOOP ; repeat if N==1"],"category":"Control Operations","name":"BN","short":"Branch if Negative"},{"description":"Branch if NOT Carry (BNC).\n\nPerforms a relative branch if the Carry flag (C) is cleared.\n- If C = 0, the program counter (PC) is updated with the relative offset specified by the label (K).\n- If C = 1, the instruction is a no‑op and execution continues with the next instruction.\n\nThe branch target is specified by a label; the assembler automatically encodes the offset.","examples":["; Branch taken if Carry cleared\nCLRC\nBNC BranchTaken ; PC jumps to BranchTaken because C=0","; Branch not taken because Carry set\nSETC\nBNC BranchTaken ; execution continues after BNC because C=1","; Simple BNC use with a label offset\nBNC OffLabel ; relative branch to OffLabel when C=0"],"category":"Control Operations","name":"BNC","short":"Branch if Not Carry"},{"description":"Branch if **Not Negative**.\n\nThe `BNN` instruction checks the **N** flag in the STATUS register. If the N flag is **0** (i.e., the previous arithmetic operation did **not** result in a negative value), the program counter is set to the supplied label, causing a jump. If the N flag is **1**, the branch is not taken and execution continues with the next instruction.\n\n### Syntax\n```asm\nBNN label\n```\n- `label` — The destination address for the branch.\n\nThe instruction has no optional words or addressing modes; its behaviour is determined solely by the value of the N flag.","examples":["; N flag cleared → branch is taken\nBNN L1   ; Jump to L1 because N = 0","; N flag set → branch is not taken\nBNN L1   ; N = 1, execution continues with the next instruction","; Demonstrating N cleared after a subtraction\nSUBWF var1, 1   ; var1 -= W → N cleared if result non‑negative\nBNN less_than_zero  ; Branch to less_than_zero because N = 0","; Using BNN after a comparison that sets N\nADDLW 0x05\nSUBWF var2, 1   ; Compare var2 with 5 → N cleared if var2 >= 5\nBNN greater_or_equal\n; Code continues here if var2 < 5, otherwise jumps to greater_or_equal"],"category":"Control Operations","name":"BNN","short":"Branch if Not Negative"},{"description":"Branch to a relative address if the **Overflow** flag (V bit in the STATUS register) is **cleared**.\nThe branch condition evaluates the V flag: if it is 0, the instruction causes the program counter (PC) to be incremented by the signed offset; if it is 1, execution continues with the next instruction.","examples":["; Branch if overflow flag is zero\nBNOV    NO_OVERFLOW ; PC jumps to NO_OVERFLOW if V == 0","; Overflow flag set (branch notBSF STATUS, 1        ; set V\nBNOV    NO_OVERFLOW ; branch not taken because V == 1","; Relative offset example (+3 instructions ahead when V == 0)\nBNOV    +3            ; skip next 3 bytes if V == 0"],"category":"Control Operations","name":"BNOV","short":"Branch if Not Overflow"},{"description":"Branch If Not Zero (BNZ)\n\nBranch to the specified label if the Zero flag (Z bit of the STATUS register) is **clear** (0), which indicates that the result of the most recent arithmetic or logical operation was non‑zero.\n- If Z = 0 → the program counter is updated to point to the given label.\n- If Z = 1 → execution continues with the following instruction.","examples":["\"; BNZ branch taken: Z flag cleared by INCFSZ\\nINCFSZ counter,0\\nBNZ skipLabel   ; jumps to skipLabel because Z=0\"","\"; BNZ branch not taken: Z flag set by CLRF\\nCLRF counter,0\\nBNZ skipLabel   ; does not jump (Z=1)\"","\"; BNZ used to jump to a label defined a few lines later\\nINCFSZ counter,0\\nBNZ targetLabel   ; jumps to targetLabel\\nNOP\\nNOP\\ntargetLabel:\\nNOP\""],"category":"Control Operations","name":"BNZ","short":"Branch if Not Zero"},{"description":"Branch if Overflow (BOV). If the **Overflow (OF)** bit (bit 2) of the **STATUS** register is set after a previous arithmetic operation, the program counter is incremented by the word offset specified by the label; otherwise execution continues with the following instruction.\n\nSyntax:\n```asm\nBOV label\n```\n\n- `label` – the branch target. The branch is taken if `OF = 1`.","examples":["; BOV taken when OF=1 → branch to L1\nBOV L1 ; PC jumps to label L1 because OF = 1","; BOV not taken when OF=0 → continue to next instruction\nBOV L2 ; PC remains on the next word because OF = 0","; BOV taken after addition that sets OF\nMOVLW 0x80\nADDLW 0x80\nBOV L3 ; OF set by signed overflow, branch to L3","; BOV not taken after addition that clears OF\nMOVLW 0x01\nADDLW 0x02\nBOV L4 ; OF cleared, no branch","; BOV taken with WREG preloaded and signed overflow from addition\nMOVLW 0x80\nADDLW 0x80\nBOV L5 ; OF set, branch to L5"],"category":"Control Operations","name":"BOV","short":"Branch if Overflow"},{"description":"Branch (BRA) – unconditional relative branch.\n- The BRA instruction alters the program counter (PC) by a signed 8‑bit displacement relative to the following instruction.\n- The operand is a label; the assembler computes the displacement.\n- It takes 2 bytes: opcode `0x80` followed by the 8‑bit offset.\n- No options (`d` or `a`).","examples":["; forward branch to FWD_LABEL\nBRA FWD_LABEL   ; branch to FWD_LABEL","; backward branch to START\nBRA START   ; return to START","; branch to the next instruction (offset 0)\nBRA NEXT_INSTR   ; no operation, PC remains at NEXT_INSTR","; branch near maximum negative offset\nBRA NEG_LIMIT   ; jumps back 126 bytes"],"category":"Control Operations","name":"BRA","short":"Branch Unconditionally"},{"description":"Branch if **Zero** flag (**Z**) is set.\n- When the **Z** flag of the STATUS register is 1, the program counter jumps to the label.\n- If **Z** is 0, execution continues with the following instruction.\n- No operands other than a label are required.","examples":["; BZ target - branch taken when Z=1\nBZ target ; Jump to target because Z flag is set","; BZ target - no branch when Z=0\nBZ target ; Execution continues with the next instruction","; BZ end - example of a label defined later in code\nBZ end   ; Branch to the end label, skipping intermediate code"],"category":"Control Operations","name":"BZ","short":"Branch if Zero"},{"description":"Call a subroutine located at a program counter address.\n- The current value of the program counter (PC) just after the CALL instruction is pushed onto the stack.\n- The processor then loads the PC with the target address, causing an unconditional jump to the subroutine.\n- After the subroutine completes, a **RETURN** instruction pops the previously saved PC from the stack and resumes execution.\n```asm\nCALL k\n```\nwhere *k* is a 16‑bit program memory address or a label referencing such an address.","examples":["; Call subroutine 'mySub' by label\nCALL mySub ; jump to subroutine at label mySub","; Call subroutine at absolute address 0x1234\nCALL 1234h ; PC set to 0x1234","; Call subroutine located at address 0x0FFE\nCALL 0x0FFEh ; jump to subroutine at address 0x0FFE"],"category":"Control Operations","name":"CALL","short":"Call subroutine"},{"description":"Clear the Watchdog Timer (WDT). This instruction resets the WDT counter to zero, effectively restarting the watchdog countdown. It is typically used in loops or before the WDT would normally expire.","examples":["; clear WDT at startup\nCLRWDT ; WDT counter reset","; clear WDT after a delay\nCLRWDT ; WDT counter restored to zero","; clear WDT in a watchdog service routine\nCLRWDT ; prevent WDT time‑out"],"category":"Control Operations","name":"CLRWDT","short":"Clear Watchdog Timer"},{"description":"Adjust the contents of **WREG** after a BCD addition or subtraction, converting the result to a valid Binary‑Coded‑Decimal (BCD) value.\n- Since the operand is implicit, the syntax contains no address or options.\n- The instruction examines the lower nibble, and if it is greater than 9, adds 6 to correct it. It then examines the upper nibble (after the lower‑nibble adjustment); if it is greater than 9 or the B flag is set, it adds 0x60. The carry flag is updated accordingly.\n- Flag updates: The Z, C, and DC bits are set based on the result.","examples":["; After successfull ADDWF, WREG harbours BCD result needing adjustment\nDAW ; adjust WREG to BCD format","; After SUBWF, WREG contains BCD difference requiring correction\nDAW ; adjust the subtraction result in WREG","; When WREG holds a correctly‑formatted BCD value already\nDAW ; no change, but flags updated","; Preloading WREG with a literal and then adjusting\nMOVLW 0x09\nDAW ; literal is already BCD, no adjustment needed","; Following an addition that set carry, WREG is adjusted and carry cleared\nADDWF 0x12, 1, 0\nDAW ; adjust resulting BCD and update carry"],"category":"Control Operations","name":"DAW","short":"Decimal Adjust WREG"},{"description":"Jump unconditionally to the given **program memory address**.\n- The *goto* instruction causes the program counter (PC) to be set to the\n  22‑bit operand **k**.\n- Execution continues at the target location without affecting any data\n  registers or status bits.\n- The operand can be an absolute address or a label that the assembler\n  resolves to an address.","examples":["; Goto absolute address 0x1234\nGOTO 0x1234 ; PC = 0x1234","; Goto label defined later in the code\nGOTO LOOP_START ; PC = address of LOOP_START","; Goto label with an EQU constant\nPAGE equ 0x2000\nGOTO PAGE ; PC = 0x2000","; Goto a relative label using back‑reference\nGOTO END\n;\nEND: ; Execution continues here after the jump"],"category":"Control Operations","name":"GOTO","short":"Go to address"},{"description":"Perform **no operation**. The instruction consumes one instruction cycle and leaves **every** register and flag unchanged.\n- **No operands**—the opcode alone encodes the operation.\n- The instruction is useful for timing adjustments or pad alignment.","examples":["; NOP does nothing\nNOP ; instruction consumes 1 cycle"],"category":"Control Operations","name":"NOP","short":"No Operation"},{"description":"The **POP** instruction removes the value at the top of the return stack (TOS) and loads it into **WREG**. The stack pointer is advanced so the next value becomes the new TOS. This instruction does not affect any status flags. It is typically used by the **RETURN** instruction or when a program wants to inspect or manipulate the return stack directly.\n\nSyntax:","examples":["; POP top of return stack (basic)\nPOP ; WREG receives the value popped from TOS","; After a CALL, POP to obtain the return address\nPOP ; WREG = return address stored by CALL","; Use POP to prepare a manual RETURN via BRA\nPOP ; WREG contains the address, next instruction could be BRA WREG","; POP inside a custom stack routine to retrieve a saved value\nPOP ; WREG holds the popped data for further processing","; POP after a chain of nested CALLs\nPOP ; WREG = deepest return address on the stack"],"category":"Control Operations","name":"POP","short":"Pop top of return stack (TOS)"},{"description":"Push the contents of the **top-of-return-stack** (TOS) onto the user stack.\n\n- **PUSH** has no operands or addressing modes.\n- It simply copies the value in TOS into the stack pointer register, thereby increasing the stack pointer.\n- The instruction is useful for saving the current return address or for manipulating the user stack.","examples":["; Push TOS onto the user stack\nPUSH ; TOS value is pushed onto the stack","; Save the current return address before a subroutine call\nPUSH ; TOS is saved on the stack","; Restore TOS after a subroutine completes\nPOP ; TOS is restored from the stack"],"category":"Control Operations","name":"PUSH","short":"Push top of return stack (TOS)"},{"description":"RCALL performs a **relative call** to a subroutine within the current program counter (PC) range. The PC is first incremented by 2 (pointing to the next instruction), then the 13‑bit signed offset `k` is added to it. The resulting address is the target of the call. The return address (next instruction address) is automatically pushed onto the stack.\n- `k` can be **positive** for forward jumps or **negative** for backward jumps, allowing calls within ±8192 bytes from the current location.\n- The instruction syntax is:","examples":["; Forward jump of 1 instruction (2 bytes ahead)\nRCALL 1 ; call subroutine at PC+2","; Forward jump across a page boundary (20 instructions ahead)\nRCALL 20 ; call subroutine 40 bytes ahead","; Backward jump of 3 instructions (6 bytes back)\nRCALL -3 ; call subroutine at PC‑6","; Maximum forward offset (example, 2047 instructions ahead)\nRCALL 2047 ; call subroutine at maximum forward range","; Short backward offset with signed literal (example)\nRCALL -1 ; return to the instruction just before the call"],"category":"Control Operations","name":"RCALL","short":"Relative Call"},{"description":"Reset the PIC18 device to its initial state via software.\n- This instruction has no operands.\n- Execution of RESET causes the microcontroller to perform a full reset, identical to a power‑on reset.","examples":["; Reset the device\nRESET ; triggers a software reset"],"category":"Control Operations","name":"RESET","short":"Software device RESET"},{"description":"Return from interrupt and re‑enable interrupts.\n- Pops the return address from the stack and loads it into the program counter.\n- Restores the I bit in the STATUS register to **1**, allowing further interrupts.\n- Should be used at the end of an interrupt service routine (ISR).\n- No operands are accepted.","examples":["; Basic return from an ISR\nRETFIE   ; Pop PC from stack, set I=1","; Return from Timer0 ISR\nRETFIE   ; Restore PC and enable interrupts again","; Return after deliberately disabling interrupts\nRETFIE   ; I bit restored to 1, execution continues in main code"],"category":"Control Operations","name":"RETFIE","short":"Return from interrupt enable"},{"description":"Load an 8‑bit literal value into **WREG** and return from the current subroutine.\n- The register **WREG** is overwritten with the specified literal.\n- The processor then performs the equivalent of a **retfie**/**return** by popping the return address from the stack and loading it into the program counter.\n- The operand is an 8‑bit immediate value.\n\n```asm\nRETLW literal\n```\n","examples":["; Return with literal 0x27 in WREG\nRETLW 0x27    ; WREG = 0x27, PC = return address"],"category":"Control Operations","name":"RETLW","short":"Return with literal in WREG"},{"description":"Return from subroutine.\n- Pops the return address from the stack and loads it into the Program Counter (PC).\n- The Stack Pointer (SP) is incremented as the address is removed.\n- Program status bits are unchanged.\n- No operands are required.","examples":["; Return from subroutine\nRETURN ; Pop PC from stack and jump to it"],"category":"Control Operations","name":"RETURN","short":"Return from Subroutine"},{"description":"Enter the processor’s Standby (sleep) mode, halting all operation until a reset occurs.","examples":["; Enter sleep mode\nSLEEP ; processor halts until reset"],"category":"Control Operations","name":"SLEEP","short":"Go into Standby mode"},{"description":"Add the literal value **k** to the contents of **WREG**. The result is written back to **WREG**. \n- **a = 0** – Access‑bank syntax (ignored by hardware, but accepted for assembler consistency).\n- **a = 1** – Banked syntax (also ignored, result is the same).","examples":["; a=0 (Access bank) → W = W + 0x05","ADDLW 0x05, 0   ; W = oldW + 5","; a=1 (Banked) → W = W + 0x05","ADDLW 0x05, 1   ; W = oldW + 5","; Pre-load WREG with literal then add","MOVLW 0x10","ADDLW 0x05      ; W = 0x10 + 5"],"category":"Literal Operations","name":"ADDLW","short":"Add literal and WREG"},{"description":"Perform a bitwise **AND** between the 8‑bit value in **WREG** and an 8‑bit literal `k`. The result overwrites **WREG**.\n\nThe literal can be specified in decimal, hexadecimal (`0x`) or octal (`0`) format. This instruction has no destination (`d`) or bank (`a`) bits; it always writes back to **WREG**.","examples":["; AND literal with WREG\nANDLW 0x0F ; W = W & 0x0F","; Load W with 0xF0 then AND it with 0x0F\nMOVLW 0xF0\nANDLW 0x0F ; W = 0xF0 & 0x0F = 0x00"],"category":"Literal Operations","name":"ANDLW","short":"AND literal with WREG"},{"description":"Perform a bitwise inclusive OR between **WREG** and an 8‑bit literal value.\n- The result of the operation is stored back into **WREG**.\n- The status register **Z** is set if the resulting value is zero; otherwise it is cleared.\n- This instruction does **not** affect the carry flag or any other status bits.","examples":["; W=0x20 before\nIORLW 0x10 ; W = 0x20 | 0x10 = 0x30","; W=0x00 before\nIORLW 0xFF ; W = 0x00 | 0xFF = 0xFF","; W=0xF0 before\nIORLW 0x0F ; W = 0xF0 | 0x0F = 0xFF","; W already contains 0x1C, OR with 0x2A\nIORLW 0x2A ; W = 0x1C | 0x2A = 0x3F"],"category":"Literal Operations","name":"IORLW","short":"Inclusive OR literal with WREG"},{"description":"Move a 16‑bit literal value into a File Select Register (FSRx). The `a` operand selects the FSR register to be loaded: 0 for FSR0, 1 for FSR1, (and 2 for FSR2 on devices that support it). The literal `f` is split into the low and high bytes and transferred into the chosen FSR pair (FSRxL and FSRxH). This instruction is useful to set an indirect address for subsequent file register access.\n\n```asm\nLFSR f, a\n```\n- **f** – 16‑bit literal used as the address to load.\n- **a** – selects the destination FSR register (0 = FSR0, 1 = FSR1, 2 = FSR2).","examples":["; Load FSR0 with address 0x1234\nLFSR 0x1234, 0 ; FSR0 = 0x1234","; Load FSR1 with address 0x5678\nLFSR 0x5678, 1 ; FSR1 = 0x5678","; Load FSR2 with address 0xABCD (supported on devices with FSR2)\nLFSR 0xABCD, 2 ; FSR2 = 0xABCD"],"category":"Literal Operations","name":"LFSR","short":"Move literal to FSRx"},{"description":"Move a 4‑bit literal value into the **BSR** (Bank Select Register) bits 3:0.\n- The literal must be in the range 0x0–0xF.\n- Only the low four bits of BSR are affected; the upper bits remain unchanged.\n- This instruction is used to switch the active bank for file register accesses.","examples":["; Load BSR with 0x0 (bank 0)\nMOVLB 0x0 ; BSR<3:0> = 0x0","; Load BSR with 0x5 (bank 5)\nMOVLB 0x5 ; BSR<3:0> = 0x5","; Load BSR with 0xF (bank 15)\nMOVLB 0xF ; BSR<3:0> = 0xF","; Example: switch to bank 2 before accessing a register\nMOVLB 0x2 ; switch to bank 2\nMOVF 0x10, W ; read from register 0x10 in bank 2"],"category":"Literal Operations","name":"MOVLB","short":"Move literal to BSR<3:0>"},{"description":"Move a literal 8‑bit value into the working register **WREG**.\n- The operand `k` is an 8‑bit constant (0x00–0xFF).\n- The instruction has no additional options.","examples":["; Load 0x00 into WREG\nMOVLW 0x00 ; W = 0x00","; Load 0xFF into WREG\nMOVLW 0xFF ; W = 0xFF","; Load 0x12 into WREG\nMOVLW 0x12 ; W = 0x12"],"category":"Literal Operations","name":"MOVLW","short":"Move literal to WREG"},{"description":"Multiply the contents of **WREG** by an 8‑bit literal value and store the 8‑bit product back into **WREG**. The upper byte of the 16‑bit product is discarded.","examples":["; Multiply W by 2, result in W\nMULLW 0x02  ; W = W * 2","; Multiply W by 16, result in W\nMULLW 0x10  ; W = W * 16","; Multiply W by 255, overflow truncates the high byte\nMULLW 0xFF  ; W = W * 255","; Multiply W by 0, zero out W\nMULLW 0x00  ; W = 0","; Load W with 0x03, then multiply by 5 => W = 0x03 * 5\nMOVLW 0x03\nMULLW 0x05  ; W = 0x03 * 5"],"category":"Literal Operations","name":"MULLW","short":"Multiply literal with WREG"},{"description":"Load an 8‑bit literal value into **WREG** and return from the current subroutine.\n- The register **WREG** is overwritten with the specified literal.\n- The processor then performs the equivalent of a **retfie**/**return** by popping the return address from the stack and loading it into the program counter.\n- The operand is an 8‑bit immediate value.\n\n```asm\nRETLW literal\n```\n","examples":["; Return with literal 0x27 in WREG\nRETLW 0x27    ; WREG = 0x27, PC = return address"],"category":"Literal Operations","name":"RETLW","short":"Return with literal in WREG"},{"description":"Subtract the contents of **WREG** from an 8‑bit literal constant `k`. The result is written back to **WREG**.\n- Operation: `WREG = k - WREG`.\n- Status bits (C, Z, DC, OV) are updated as with any 8‑bit subtraction. The result is always stored to **WREG** regardless of flags.","examples":["; From literal, WREG=5, literal=10 → W=5\nMOVLW 0x05\nSUBLW 0x0A","; Underflow, WREG=2, literal=0 → W=0xFE\nMOVLW 0x02\nSUBLW 0x00","; Borrow across the high byte, WREG=0xFF, literal=0x80 → W=0x81\nMOVLW 0xFF\nSUBLW 0x80","; Zero result, WREG=0, literal=0 → W=0\nMOVLW 0x00\nSUBLW 0x00","; Literal pre‑load then subtract, result in W\nMOVLW 0x12\nSUBLW 0x20   ; W = 0x20 - 0x12 = 0x0E"],"category":"Literal Operations","name":"SUBLW","short":"Subtract WREG from literal"},{"description":"Exclusive OR the contents of **WREG** with a literal.\nThe 8‑bit literal is XORed with WREG and the result is written back into **WREG**. No operand options are available for this instruction.","examples":["; XOR a literal with WREG\nXORLW 0x55 ; W = W ^ 0x55","; XOR with 0x00 (no change)\nXORLW 0x00 ; W = W ^ 0x00","; Load WREG then XOR with another literal\nMOVLW 0x12\nXORLW 0x34 ; W = 0x12 ^ 0x34 = 0x26"],"category":"Literal Operations","name":"XORLW","short":"Exclusive OR literal with WREG"},{"description":"Read the contents of the table location pointed to by the 21‑bit table pointer (`TBLPTR`) into **WREG**. The address is formed by combining the 8‑bit `TBLPAG` page register with the `TBLPTR` register. The `TBLRD` instruction is a single‑word instruction that has no operands or options; it always writes the retrieved byte into **WREG**.\n\n- `TBLPAG`: 8‑bit register that selects the current table page.\n- `TBLPTR`: 16‑bit register that holds the low and high byte of the table address.\n- The instruction reads the byte at address (`TBLPAG << 8 | TBLPTR`) and places it in **WREG**.","examples":["; TBLPAG=0, TBLPTR=0x0005 (address 5), read into WREG\nTBLRD ; WREG = table[5]","; TBLPAG=1, TBLPTR=0x0100 (address 256 within page 1), read into WREG\nTBLRD ; WREG = table[0x100]","; TBLPAG=2, TBLPTR=0x0200 (address 512), read into WREG\nTBLRD ; WREG = table[0x200]","; TBLPAG=0, TBLPTR=0x00FF (address 255), read into WREG\nTBLRD ; WREG = table[0xFF]"],"category":"Data & Program Memory Operations","name":"TBLRD*","short":"Table Read"},{"description":"The **TBLRD+** instruction reads an 8‑bit byte from program memory at the address currently held in the Table Pointer registers (TBLPAG, TBLPTRU, TBLPTRH, TBLPTRL). The value read is moved into **WREG**.\n\nAfter the data is transferred, the Table Pointer is **post‑incremented**, so the next execution of **TBLRD+** will read the next byte in program memory.\n\n- The instruction has no destination (`d`) or access‑bank (`a`) operands; it operates on the current table pointer value.\n- It is used in conjunction with the `TBLPTR` registers, which must be loaded beforehand.\n- A variant, **TBLRD-**, performs a post‑decrement.","examples":["; Assume TBLPAG = 0x00: read first byte of a table\nTBLRD+ ; W = program memory[0x00], TBLPAG becomes 0x01","; Assume TBLPAG = 0x1F: read a mid‑range table entry\nTBLRD+ ; W = program memory[0x1F], TBLPAG becomes 0x20","; Assume TBLPAG = 0xFF: read the last byte of the current bank\nTBLRD+ ; W = program memory[0xFF], TBLPAG becomes 0x100 (wraps to next bank if applicable)","; After reading at 0x00 with TBLRD+, TBLPAG is 0x01: read the next entry\nTBLRD+ ; W = program memory[0x01], TBLPAG becomes 0x02","; Assume TBLPAG = 0x80: read a byte near the middle of program memory\nTBLRD+ ; W = program memory[0x80], TBLPAG becomes 0x81"],"category":"Data & Program Memory Operations","name":"TBLRD*+","short":"Table Read with post-increment"},{"description":"Read a word from program memory at the address held in the **Table Pointer** registers (`TBLPTRU:TBLPTRH:TBLPTRL`).\n- `*` suffix → the Table Pointer is **post‑decremented** after the transfer.\n- `d = 0` → result is stored in **WREG**.\n- `d = 1` → result is stored back into register `f`.\n- `a = 0` → destination file register is addressed in the **access bank**.\n- `a = 1` → destination file register is addressed in a **banked** RAM area.\n```asm\nTBLRD* f, [d], [a]\n```\nThe instruction is typically used after setting `TBLPTR` to the desired program‑memory location; the read transfers the 16‑bit word at that address into the destination and then decrements `TBLPTR` by one (because of the `*`).","examples":["; d=0, a=0  → result in WREG, Access bank","TBLRD* 0x20, 0, 0   ; WREG = PGM[ TBLPTR ]; TBLPTR decremented","; d=0, a=1  → result in WREG, Banked address","TBLRD* 0x20, 0, 1   ; WREG = PGM[ TBLPTR ]; TBLPTR decremented","; d=1, a=0  → result back to file register, Access bank","TBLRD* 0x20, 1, 0   ; 0x20 = PGM[ TBLPTR ]; TBLPTR decremented","; d=1, a=1  → result back to file register, Banked address","TBLRD* 0x20, 1, 1   ; 0x20 = PGM[ TBLPTR ]; TBLPTR decremented","; Load WREG with a literal, then perform table read (d=0)","MOVLW 0x10\nTBLRD* 0x20, 0, 0   ; WREG overwritten with PGM[ TBLPTR ]; TBLPTR decremented"],"category":"Data & Program Memory Operations","name":"TBLRD*-","short":"Table Read with post-decrement"},{"description":"Read a byte from program memory using the table read mechanism.\n- The instruction increments the table pointer (TBLPTR) **before** the read operation (pre‑increment).\n- The byte located at the new TBLPTR address is copied into the table register **TBLR**.\n- The increment is performed on the full 23‑bit TBLPTR (TBLPTRU:TBLPTRH:TBLPTRL).\n- The result is not automatically transferred to WREG; a subsequent **MOVF TBLR, W** is typically used to obtain the value in WREG.\n- The instruction has no operands or address options.","examples":["; TBLRD+* – pre‑increment read from address 0x0124 (TBLPTR=0x0123 before)\nTBLRD+* ; TBLR = byte at 0x0124, TBLPTR becomes 0x0124","; TBLRD+* – read from start of program memory, TBLPTR=0x0000\nTBLRD+* ; TBLR = byte at 0x0001, TBLPTR becomes 0x0001","; TBLRD+* – pre‑increment from a high address 0xFFFFE (TBLPTR=0xFFFFE)\nTBLRD+* ; TBLR = byte at 0xFFFFF, TBLPTR becomes 0xFFFFF"],"category":"Data & Program Memory Operations","name":"TBLRD+*","short":"Table Read with pre-increment"},{"description":"Store the 8‑bit contents of **WREG** into the memory location pointed to by the table pointer (`TBLPTR`) and the table page register (`TBLPAG`).\n\n- The instruction name is **TBLWT** (Table Write). It has no operands; the destination address is formed from the high byte of `TBLPTR` and the 8‑bit `TBLPAG` value.\n- After executing `TBLWT`, the data in **WREG** is written to SRAM in the selected table page.\n- The instruction should be used only when the Table Pointer has been correctly initialized by loading `TBLPTRL`, `TBLPTRH` (and optionally `TBLPTRU` for 16‑bit) and setting `TBLPAG`.\n\n```asm\nTBLWT\n```\n","examples":["; Example 1: Write 0x12 to table address 0x0000 (default page 0)\nMOVLW 0x12\nTBLWT","; Example 2: Set table page to 1 and write 0x22 to address 0x0100\nMOVLW 0x22\nMOVWF TBLPAG\nMOVLW 0x00\nMOVWF TBLPTRL\nMOVLW 0x01\nMOVWF TBLPTRH\nTBLWT","; Example 3: Write 0x44, then read back with TBLRD\nMOVLW 0x44\nTBLWT\nMOVLW 0x00\nTBLRD\n"],"category":"Data & Program Memory Operations","name":"TBLWT*","short":"Table Write"},{"description":"Write the contents of **WREG** into the table location addressed by **TBLPTR**, then post‑increment **TBLPTR** by one.\n- The instruction has no operands.\n- After the write, **TBLPTR** automatically increments, so the next write will address the following byte.","examples":["; TBLPTR set to 0x2000, WREG contains 0xAB – write and increment\nTBLWR+I ; writes 0xAB to table at 0x2000; TBLPTR becomes 0x2001","; TBLPTR set to 0x200F, WREG contains 0x55 – write and increment across page boundary\nTBLWR+I ; writes 0x55 to 0x200F; TBLPTR becomes 0x2010","; TBLPTR pre‑loaded with 0x3000, WREG = 0x00 – clear table byte and increment\nTBLWR+I ; writes 0x00 to 0x3000; TBLPTR becomes 0x3001","; WREG has been loaded with a literal value (e.g., MOVLW 0x10 was executed before)\nTBLWR+I ; writes 0x10 to the table address in TBLPTR; TBLPTR increments by one"],"category":"Data & Program Memory Operations","name":"TBLWT*+","short":"Table Write with post-increment"},{"description":"Table Write with **post‑decrement**.\n\nThe `TBLWT*` instruction transfers the contents of **WREG** to the table memory location currently referenced by the 13‑bit **TBLPTR** registers, and then decrements **TBLPTR** by one.  The instruction has no operands and takes no `d` or `a` options.\n\n* **Use** – `TBLPTR` must be loaded with the desired address before the instruction is executed.\n* **Result** – After the write, `WREG` remains unchanged, the byte is stored at the original address, and `TBLPTR` now points to the previous table location.\n\n```asm\nTBLWT*\n```\n","examples":["; Set TBLPTR to 0x2000, write value 0x5A from WREG, decrement pointer\nMOVLW 0x00\nMOVWF TBLPTRL\nMOVLW 0x20\nMOVWF TBLPTH\nMOVLW 0x5A\nTBLWT* ; 0x5A written to 0x2000, TBLPTR becomes 0x1FFF","; Write two consecutive values using post‑decrement\nMOVLW 0xFF\nMOVWF TBLPTRL\nMOVLW 0x01\nMOVWF TBLPTH\nMOVLW 0xAA\nTBLWT* ; writes 0xAA to 0x1FFF, TBLPTR=0x1FFE\nMOVLW 0xBB\nTBLWT* ; writes 0xBB to 0x1FFE, TBLPTR=0x1FFD","; Demonstrate successive writes – TBLPTR decrements again\nMOVLW 0x00\nMOVWF TBLPTRL\nMOVLW 0x20\nMOVWF TBLPTH\nMOVLW 0x5A\nTBLWT* ; writes 0x5A to 0x2000, TBLPTR=0x1FFF\nMOVLW 0x6B\nTBLWT* ; writes 0x6B to 0x1FFF, TBLPTR=0x1FFE"],"category":"Data & Program Memory Operations","name":"TBLWT*-","short":"Table Write with post-decrement"},{"description":"Write the contents of **WREG** to the table memory location addressed by **TBLPAG** and the 16‑bit **TBLPTR** registers.\n\nThe `+*` suffix indicates a *pre‑increment* operation: the table pointer is incremented **before** the write takes place. After execution the updated **TBLPTR** points to the next address. The instruction does not affect any status bits.\n\nThe pointer increment wraps around, carrying into **TBLPAG** as necessary.","examples":["; WREG=0x55, TBLPAG=0x00, TBLPTR=0x0010 before execution\nTBLWT+* ; WREG written to table address (after pre‑increment)","; WREG=0xA5, TBLPAG=0x01, TBLPTR=0x00FF before execution (carry into high byte)\nTBLWT+* ; WREG written to address 0x0100","; WREG=0x00, TBLPAG=0x00, TBLPTR=0xFFFF before execution\nTBLWT+* ; pointer overflows to 0x0000, WREG written at 0x0000"],"category":"Data & Program Memory Operations","name":"TBLWT+*","short":"Table Write with pre-increment"}]